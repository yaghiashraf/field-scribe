"use client";

import { useState } from "react";
import {
  Loader2,
  FileText,
  Download,
  Wand2,
  FileType,
  AlertCircle,
  Copy,
  CheckCheck,
} from "lucide-react";
import { generateReport } from "../actions/generate-report";
import { InspectionDetailsData } from "./InspectionDetails";
import { ImageResult } from "./PhotoUploader";
import { jsPDF } from "jspdf";

interface Props {
  notes: string[];
  images: ImageResult[];
  details: InspectionDetailsData;
}

export function ReportGenerator({ notes, images, details }: Props) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [report, setReport] = useState<string>("");
  const [errorMsg, setErrorMsg] = useState<string>("");
  const [copied, setCopied] = useState(false);

  const hasData = notes.length > 0 || images.length > 0;
  const hasDetails = !!(details.inspectorName || details.propertyAddress);

  const handleGenerate = async () => {
    if (!hasDetails) {
      setErrorMsg("Please fill in Inspector Name and Property Address.");
      return;
    }
    if (!hasData) {
      setErrorMsg("Please add at least one photo or voice note.");
      return;
    }

    setIsGenerating(true);
    setErrorMsg("");

    // Extract descriptions for the AI
    const imageDescriptions = images
        .filter(img => img.status === 'success')
        .map(img => img.analysis);

    const res = await generateReport({
      notes: notes.join("\n"),
      imageDescriptions,
      details,
    });

    if (res.success && res.report) {
      setReport(res.report);
    } else {
      setErrorMsg(res.error || "Generation failed.");
    }
    setIsGenerating(false);
  };

  const handleCopy = async () => {
    await navigator.clipboard.writeText(report);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleDownloadText = () => {
    const slug = (details.propertyAddress || "inspection")
      .replace(/[^a-z0-9]/gi, "-")
      .toLowerCase();
    const el = document.createElement("a");
    el.href = URL.createObjectURL(new Blob([report], { type: "text/plain" }));
    el.download = `Report-${slug}.txt`;
    el.click();
  };

  const handleDownloadPDF = async () => {
    const doc = new jsPDF({ unit: "mm", format: "a4" });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 15;
    const contentW = pageW - margin * 2 - 20; // Increased buffer to 20mm for right margin safety
    let y = margin;

    const addFooter = (pageNum: number) => {
        doc.setFontSize(8);
        doc.setTextColor(150);
        doc.text(`Page ${pageNum} | Generated by FieldScribe`, pageW / 2, pageH - 8, { align: 'center' });
    };

    let pageCount = 1;

    const newPage = () => {
      addFooter(pageCount);
      doc.addPage();
      pageCount++;
      y = margin;
    };

    const checkSpace = (height: number) => {
      if (y + height > pageH - 20) newPage();
    };

    // ── COVER PAGE ──
    // Header Bar
    doc.setFillColor(55, 65, 81); // Slate 700
    doc.rect(0, 0, pageW, 20, "F");
    
    doc.setFont("helvetica", "bold");
    doc.setFontSize(16);
    doc.setTextColor(255, 255, 255);
    doc.text("INSPECTION REPORT", margin, 13);
    
    y = 40;

    // Property Photo
    if (images.length > 0) {
        try {
            let coverImgIndex = 0;
            const keywords = ["exterior", "house", "front", "building", "elevation", "street", "facade"];
            
            for (let i = 0; i < images.length; i++) {
                const desc = images[i].analysis.toLowerCase();
                if (keywords.some(k => desc.includes(k))) {
                    coverImgIndex = i;
                    break;
                }
            }

            const coverImg = images[coverImgIndex];
            const imgProps = doc.getImageProperties(coverImg.preview);
            const imgH = (imgProps.height * contentW) / imgProps.width;
            
            const maxH = 110; 
            const finalH = imgH > maxH ? maxH : imgH;
            
            doc.addImage(coverImg.preview, "JPEG", margin, y, contentW, finalH);
            y += finalH + 15;
        } catch (err) {
            console.warn("Could not add cover image", err);
        }
    } else {
        doc.setFillColor(240, 240, 240);
        doc.rect(margin, y, contentW, 80, "F");
        doc.setTextColor(150);
        doc.setFontSize(14);
        doc.text("No Property Photo", pageW/2, y + 40, { align: 'center' });
        y += 90;
    }

    doc.setTextColor(30);
    doc.setFontSize(22);
    doc.setFont("helvetica", "bold");
    doc.text(details.propertyAddress || "Property Address Not Provided", margin, y);
    y += 10;

    doc.setFontSize(12);
    doc.setFont("helvetica", "normal");
    doc.text(`Client: ${details.clientName || "—"}`, margin, y);
    y += 6;
    doc.text(`Date: ${details.date}`, margin, y);
    y += 15;

    doc.setDrawColor(200);
    doc.setFillColor(250, 250, 250);
    doc.roundedRect(margin, y, contentW, 35, 2, 2, "FD");
    doc.setTextColor(30);
    doc.setFont("helvetica", "bold");
    doc.text("INSPECTOR", margin + 5, y + 8);
    doc.setFont("helvetica", "normal");
    doc.text(details.inspectorName || "—", margin + 5, y + 16);
    doc.text(details.companyName || "", margin + 5, y + 22);
    doc.text(details.companyAddress || "", margin + 5, y + 28);
    
    addFooter(pageCount);
    doc.addPage();
    pageCount++;
    y = margin;

    // ── REPORT BODY ──
    const lines = report.split("\n");

    for (const rawLine of lines) {
      const line = rawLine.trimEnd();

      if (line.startsWith("# ")) continue; 

      if (line.startsWith("## ")) {
        checkSpace(20);
        y += 8;
        doc.setFillColor(240, 242, 245); 
        doc.rect(margin, y, contentW, 10, "F");
        doc.setFontSize(12);
        doc.setFont("helvetica", "bold");
        doc.setTextColor(55, 65, 81);
        doc.text(line.replace(/^## /, "").toUpperCase(), margin + 2, y + 7);
        y += 16;
        continue;
      }

      if (line.startsWith("### ")) {
        checkSpace(15);
        y += 5;
        doc.setDrawColor(200);
        doc.setLineWidth(0.1);
        doc.line(margin, y, margin + contentW, y);
        y += 6;
        doc.setFontSize(11);
        doc.setFont("helvetica", "bold");
        doc.setTextColor(30);
        doc.text(line.replace(/^### /, ""), margin, y);
        y += 7;
        continue;
      }

      if (line.includes("**")) {
        checkSpace(6);
        const parts = line.split("**");
        let currentX = margin;
        let indent = 0;

        // Check for list item indent
        if (line.trim().startsWith("- ") || line.trim().startsWith("• ")) {
            indent = 5;
            currentX += indent;
            doc.text("•", margin, y);
        }

        doc.setFontSize(10);
        doc.setTextColor(30);

        parts.forEach((part, i) => {
            if (!part) return;
            // Odd indices are bold (0: normal, 1: bold, 2: normal...)
            const isBold = i % 2 === 1;
            
            doc.setFont("helvetica", isBold ? "bold" : "normal");
            
            // Remove bullet markers from the text part itself if we handled it above
            let cleanPart = part;
            if (i === 0 && (cleanPart.trim().startsWith("- ") || cleanPart.trim().startsWith("• "))) {
                cleanPart = cleanPart.replace(/^[-•] /, "");
            }

            // Split by words but preserve spaces
            const words = cleanPart.split(/(\s+)/); 
            
            words.forEach(word => {
                const wordW = doc.getTextWidth(word);
                // Check if adding this word exceeds the printable area
                if (currentX + wordW > margin + contentW) {
                    y += 5; // Move to next line
                    currentX = margin + indent; // Reset X with indent
                    checkSpace(5); // Check if we need a new page
                }
                doc.text(word, currentX, y);
                currentX += wordW;
            });
        });
        y += 6; // Space after paragraph
        continue;
      }

      if (line.startsWith("- ") || line.startsWith("• ")) {
        checkSpace(6);
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(50);
        const text = line.replace(/^[-•] /, "");
        // Fix: Subtract indent (5mm) from max width so it wraps earlier
        const splitText = doc.splitTextToSize(text, contentW - 5);
        doc.text("•", margin, y);
        doc.text(splitText, margin + 5, y);
        y += (splitText.length * 5) + 2;
        continue;
      }

      if (line.length > 0) {
        checkSpace(5);
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(50);
        const splitText = doc.splitTextToSize(line, contentW);
        doc.text(splitText, margin, y);
        y += (splitText.length * 5) + 2;
      }
    }

    if (images.length > 0) {
        doc.addPage();
        pageCount++;
        y = margin;
        doc.setFillColor(240, 242, 245);
        doc.rect(margin, y, contentW, 10, "F");
        doc.setFontSize(12);
        doc.setFont("helvetica", "bold");
        doc.setTextColor(55, 65, 81);
        doc.text("PHOTO ADDENDUM", margin + 2, y + 7);
        y += 18;

        for (let i = 0; i < images.length; i++) {
            const img = images[i];
            checkSpace(110); 
            try {
                const imgProps = doc.getImageProperties(img.preview);
                const ratio = imgProps.width / imgProps.height;
                const imgW = 120;
                const imgH = imgW / ratio;
                doc.addImage(img.preview, "JPEG", margin, y, imgW, imgH);
                doc.setFontSize(9);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(30);
                doc.text(`Photo ${i+1}: Item of Interest`, margin + imgW + 5, y + 5);
                doc.setFontSize(9);
                doc.setFont("helvetica", "normal");
                doc.setTextColor(80);
                const cleanDesc = img.analysis.replace(/^Description:\s*/i, "");
                const splitCaption = doc.splitTextToSize(cleanDesc, contentW - imgW - 10);
                doc.text(splitCaption, margin + imgW + 5, y + 12);
                y += imgH + 15;
            } catch (err) {
                console.error("Error adding image to PDF", err);
            }
        }
        addFooter(pageCount);
    }

    const slug = (details.propertyAddress || "report").replace(/[^a-z0-9]/gi, "-");
    doc.save(`FieldScribe-Report-${slug}.pdf`);
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="text-sm text-slate-400">
          {images.length} photo{images.length !== 1 ? "s" : ""}, {notes.length} note{notes.length !== 1 ? "s" : ""}
        </div>
        <button
          onClick={handleGenerate}
          disabled={isGenerating || (!hasData && !hasDetails)}
          className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-semibold hover:bg-indigo-700 disabled:opacity-40 disabled:cursor-not-allowed shadow-sm transition-all hover:shadow-md"
        >
          {isGenerating ? <Loader2 className="w-4 h-4 animate-spin" /> : <Wand2 className="w-4 h-4" />}
          {isGenerating ? "Generating..." : report ? "Regenerate" : "Generate Report"}
        </button>
      </div>

      {errorMsg && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-100 rounded-lg text-sm text-red-700">
          <AlertCircle className="w-4 h-4 shrink-0 mt-0.5" />
          <span>{errorMsg}</span>
        </div>
      )}

      {report ? (
        <div className="border border-slate-200 rounded-xl bg-white shadow-sm overflow-hidden">
          <div className="flex items-center justify-between px-4 py-2.5 border-b border-slate-100 bg-slate-50">
            <span className="text-xs font-medium text-slate-500 uppercase tracking-wide">
              Preview
            </span>
            <div className="flex gap-2">
              <button onClick={handleCopy} className="text-xs flex gap-1 items-center px-2 py-1 text-slate-600 hover:bg-slate-200 rounded">
                {copied ? <CheckCheck className="w-3.5 h-3.5 text-green-500" /> : <Copy className="w-3.5 h-3.5" />} Copy
              </button>
              <button onClick={handleDownloadText} className="text-xs flex gap-1 items-center px-2 py-1 text-slate-600 hover:bg-slate-200 rounded">
                <FileType className="w-3.5 h-3.5" /> TXT
              </button>
              <button onClick={handleDownloadPDF} className="text-xs flex gap-1 items-center px-3 py-1 bg-slate-900 text-white hover:bg-slate-700 rounded">
                <Download className="w-3.5 h-3.5" /> Download PDF
              </button>
            </div>
          </div>
          <div className="p-6 max-h-[600px] overflow-y-auto">
            <div className="prose prose-sm max-w-none text-slate-800">
                {report.split('\n').map((line, i) => (
                    <p key={i} className={line.startsWith('#') ? "font-bold text-slate-900 mt-4 border-b border-slate-100 pb-1" : "mb-2"}>
                        {line.replace(/[#*]/g, '')}
                    </p>
                ))}
            </div>
          </div>
        </div>
      ) : (
        <div className="border-2 border-dashed border-slate-100 rounded-xl p-12 text-center text-slate-400 bg-slate-50/50">
          <FileText className="h-10 w-10 mx-auto mb-3 opacity-20" />
          <p className="text-sm">Ready to generate.</p>
        </div>
      )}
    </div>
  );
}
