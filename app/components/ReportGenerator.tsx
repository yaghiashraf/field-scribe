"use client";

import { useState } from "react";
import {
  Loader2,
  FileText,
  Download,
  Wand2,
  FileType,
  AlertCircle,
  Copy,
  CheckCheck,
} from "lucide-react";
import { generateReport } from "../actions/generate-report";
import { InspectionDetailsData } from "./InspectionDetails";
import { ImageResult } from "./PhotoUploader";
import { jsPDF } from "jspdf";

interface Props {
  notes: string[];
  images: ImageResult[];
  details: InspectionDetailsData;
}

export function ReportGenerator({ notes, images, details }: Props) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [report, setReport] = useState<string>("");
  const [errorMsg, setErrorMsg] = useState<string>("");
  const [copied, setCopied] = useState(false);

  const hasData = notes.length > 0 || images.length > 0;
  const hasDetails = !!(details.inspectorName || details.propertyAddress);

  const handleGenerate = async () => {
    if (!hasDetails) {
      setErrorMsg("Please fill in Inspector Name and Property Address.");
      return;
    }
    if (!hasData) {
      setErrorMsg("Please add at least one photo or voice note.");
      return;
    }

    setIsGenerating(true);
    setErrorMsg("");

    // Extract descriptions for the AI
    const imageDescriptions = images
        .filter(img => img.status === 'success')
        .map(img => img.analysis);

    const res = await generateReport({
      notes: notes.join("\n"),
      imageDescriptions,
      details,
    });

    if (res.success && res.report) {
      setReport(res.report);
    } else {
      setErrorMsg(res.error || "Generation failed.");
    }
    setIsGenerating(false);
  };

  const handleCopy = async () => {
    await navigator.clipboard.writeText(report);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleDownloadText = () => {
    const slug = (details.propertyAddress || "inspection")
      .replace(/[^a-z0-9]/gi, "-")
      .toLowerCase();
    const el = document.createElement("a");
    el.href = URL.createObjectURL(new Blob([report], { type: "text/plain" }));
    el.download = `Report-${slug}.txt`;
    el.click();
  };

  const handleDownloadPDF = async () => {
    const doc = new jsPDF({ unit: "mm", format: "a4" });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 15;
    const contentW = pageW - margin * 2;
    let y = margin;

    const addFooter = (pageNum: number) => {
        doc.setFontSize(8);
        doc.setTextColor(150);
        doc.text(`Page ${pageNum} | Generated by FieldScribe`, pageW / 2, pageH - 8, { align: 'center' });
    };

    let pageCount = 1;

    const newPage = () => {
      addFooter(pageCount);
      doc.addPage();
      pageCount++;
      y = margin;
    };

    const checkSpace = (height: number) => {
      if (y + height > pageH - 20) newPage();
    };

    // ── COVER PAGE ──
    // Header Bar
    doc.setFillColor(55, 65, 81); // Slate 700
    doc.rect(0, 0, pageW, 20, "F");
    
    doc.setFont("helvetica", "bold");
    doc.setFontSize(16);
    doc.setTextColor(255, 255, 255);
    doc.text("INSPECTION REPORT", margin, 13);
    
    y = 40;

    // Property Photo (Use first uploaded image if available)
    if (images.length > 0) {
        try {
            // Get the first image
            const coverImg = images[0];
            const imgProps = doc.getImageProperties(coverImg.preview);
            const imgH = (imgProps.height * contentW) / imgProps.width;
            
            // Limit cover image height
            const maxH = 100; 
            const finalH = imgH > maxH ? maxH : imgH;
            
            doc.addImage(coverImg.preview, "JPEG", margin, y, contentW, finalH);
            y += finalH + 10;
        } catch (err) {
            console.warn("Could not add cover image", err);
        }
    } else {
        // Placeholder box if no images
        doc.setFillColor(240, 240, 240);
        doc.rect(margin, y, contentW, 80, "F");
        doc.setTextColor(150);
        doc.setFontSize(14);
        doc.text("No Property Photo", pageW/2, y + 40, { align: 'center' });
        y += 90;
    }

    // Property Details
    doc.setTextColor(30);
    doc.setFontSize(22);
    doc.setFont("helvetica", "bold");
    doc.text(details.propertyAddress || "Property Address Not Provided", margin, y);
    y += 10;

    doc.setFontSize(12);
    doc.setFont("helvetica", "normal");
    doc.text(`Client: ${details.clientName || "—"}`, margin, y);
    y += 6;
    doc.text(`Date: ${details.date}`, margin, y);
    y += 15;

    // Inspector Badge
    doc.setDrawColor(200);
    doc.roundedRect(margin, y, contentW, 35, 2, 2);
    doc.setFont("helvetica", "bold");
    doc.text("INSPECTOR", margin + 5, y + 8);
    doc.setFont("helvetica", "normal");
    doc.text(details.inspectorName || "—", margin + 5, y + 16);
    doc.text(details.companyName || "", margin + 5, y + 22);
    doc.text(details.companyAddress || "", margin + 5, y + 28);
    
    // Add footer to cover page and start new page
    addFooter(pageCount);
    doc.addPage();
    pageCount++;
    y = margin;

    // ── REPORT BODY ──
    
    const lines = report.split("\n");

    for (const rawLine of lines) {
      const line = rawLine.trimEnd();

      if (line.startsWith("# ")) {
        // Main Header (ignore if duplicates cover info, otherwise print)
        continue; // We already have a cover page
      }

      if (line.startsWith("## ")) {
        // Section Header
        checkSpace(15);
        y += 5;
        doc.setFillColor(240, 242, 245); // Light gray bg
        doc.rect(margin, y, contentW, 10, "F");
        doc.setFontSize(12);
        doc.setFont("helvetica", "bold");
        doc.setTextColor(55, 65, 81);
        doc.text(line.replace(/^## /, "").toUpperCase(), margin + 2, y + 7);
        y += 15;
        continue;
      }

      if (line.startsWith("**") || line.includes("**")) {
        // Bold Key-Value pairs (e.g. **Observation:** ...)
        checkSpace(6);
        doc.setFontSize(10);
        doc.setTextColor(30);
        
        // Simple bold parsing: split by **
        const parts = line.split("**");
        let currentX = margin;
        
        parts.forEach((part, i) => {
            if (part === "") return;
            doc.setFont("helvetica", i % 2 === 1 ? "bold" : "normal"); // Odd parts are bold
            doc.text(part, currentX, y);
            currentX += doc.getStringUnitWidth(part) * 3.52; // Approx width scaling
        });
        y += 6;
        continue;
      }

      if (line.startsWith("- ") || line.startsWith("• ")) {
        // Bullet points
        checkSpace(6);
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(50);
        const text = line.replace(/^[-•] /, "");
        
        // Handle long bullets
        const splitText = doc.splitTextToSize(text, contentW - 5);
        doc.text("•", margin, y);
        doc.text(splitText, margin + 5, y);
        y += (splitText.length * 5) + 2;
        continue;
      }

      // Standard Paragraph
      if (line.length > 0) {
        checkSpace(5);
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(50);
        const splitText = doc.splitTextToSize(line, contentW);
        doc.text(splitText, margin, y);
        y += (splitText.length * 5) + 2;
      }
    }

    // ── PHOTO ADDENDUM ──
    // Add photos at the end
    if (images.length > 0) {
        doc.addPage();
        pageCount++;
        y = margin;
        
        doc.setFont("helvetica", "bold");
        doc.setFontSize(14);
        doc.text("PHOTO ADDENDUM", margin, y);
        y += 10;

        for (let i = 0; i < images.length; i++) {
            const img = images[i];
            // 2 photos per page max
            checkSpace(110); 
            
            try {
                // Add Image
                const imgProps = doc.getImageProperties(img.preview);
                const ratio = imgProps.width / imgProps.height;
                const imgW = 120; // Fixed width
                const imgH = imgW / ratio;
                
                // Keep ratio but fit on page
                doc.addImage(img.preview, "JPEG", margin, y, imgW, imgH);
                
                // Add Caption
                doc.setFontSize(9);
                doc.setFont("helvetica", "normal");
                doc.setTextColor(100);
                const caption = `Photo ${i+1}: ${img.analysis || "Site Photo"}`;
                const splitCaption = doc.splitTextToSize(caption, contentW - imgW - 10);
                
                doc.text(splitCaption, margin + imgW + 5, y + 10);
                
                y += imgH + 15;
            } catch (err) {
                console.error("Error adding image to PDF", err);
            }
        }
        addFooter(pageCount);
    }

    const slug = (details.propertyAddress || "report").replace(/[^a-z0-9]/gi, "-");
    doc.save(`FieldScribe-${slug}.pdf`);
  };

  return (
    <div className="space-y-4">
      {/* Controls */}
      <div className="flex items-center justify-between">
        <div className="text-sm text-slate-400">
          {images.length} photo{images.length !== 1 ? "s" : ""}, {notes.length} note{notes.length !== 1 ? "s" : ""}
        </div>
        <button
          onClick={handleGenerate}
          disabled={isGenerating || (!hasData && !hasDetails)}
          className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-semibold hover:bg-indigo-700 disabled:opacity-40 disabled:cursor-not-allowed shadow-sm"
        >
          {isGenerating ? <Loader2 className="w-4 h-4 animate-spin" /> : <Wand2 className="w-4 h-4" />}
          {isGenerating ? "Generating..." : report ? "Regenerate" : "Generate Report"}
        </button>
      </div>

      {errorMsg && (
        <div className="p-3 bg-red-50 text-red-700 text-sm rounded-lg flex gap-2">
          <AlertCircle className="w-4 h-4 mt-0.5" /> {errorMsg}
        </div>
      )}

      {/* Preview */}
      {report ? (
        <div className="border border-slate-200 rounded-xl bg-white shadow-sm overflow-hidden">
          <div className="flex items-center justify-between px-4 py-2.5 border-b border-slate-100 bg-slate-50">
            <span className="text-xs font-medium text-slate-500 uppercase">Preview</span>
            <div className="flex gap-2">
              <button onClick={handleCopy} className="text-xs flex gap-1 items-center px-2 py-1 text-slate-600 hover:bg-slate-200 rounded">
                {copied ? <CheckCheck className="w-3 h-3" /> : <Copy className="w-3 h-3" />} Copy
              </button>
              <button onClick={handleDownloadText} className="text-xs flex gap-1 items-center px-2 py-1 text-slate-600 hover:bg-slate-200 rounded">
                <FileType className="w-3 h-3" /> TXT
              </button>
              <button onClick={handleDownloadPDF} className="text-xs flex gap-1 items-center px-3 py-1 bg-slate-900 text-white hover:bg-slate-700 rounded">
                <Download className="w-3 h-3" /> Download PDF
              </button>
            </div>
          </div>
          <div className="p-6 max-h-[600px] overflow-y-auto">
            <div className="prose prose-sm max-w-none text-slate-800">
                {/* Quick markdown rendering for preview */}
                {report.split('\n').map((line, i) => (
                    <p key={i} className={line.startsWith('#') ? "font-bold text-slate-900 mt-4 border-b border-slate-100 pb-1" : "mb-2"}>
                        {line.replace(/[#*]/g, '')}
                    </p>
                ))}
            </div>
          </div>
        </div>
      ) : (
        <div className="border-2 border-dashed border-slate-100 rounded-xl p-12 text-center text-slate-400 bg-slate-50/50">
          <FileText className="h-10 w-10 mx-auto mb-3 opacity-20" />
          <p className="text-sm">Ready to generate.</p>
        </div>
      )}
    </div>
  );
}
