"use client";

import { useState } from "react";
import {
  Loader2,
  FileText,
  Download,
  Wand2,
  FileType,
  AlertCircle,
  Copy,
  CheckCheck,
} from "lucide-react";
import { generateReport } from "../actions/generate-report";
import { InspectionDetailsData } from "./InspectionDetails";
import { ImageResult } from "./PhotoUploader";
import { jsPDF } from "jspdf";

interface Props {
  notes: string[];
  images: ImageResult[];
  details: InspectionDetailsData;
}

export function ReportGenerator({ notes, images, details }: Props) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [report, setReport] = useState<string>("");
  const [errorMsg, setErrorMsg] = useState<string>("");
  const [copied, setCopied] = useState(false);

  const hasData = notes.length > 0 || images.length > 0;
  const hasDetails = !!(details.inspectorName || details.propertyAddress);

  const handleGenerate = async () => {
    if (!hasDetails) {
      setErrorMsg("Please fill in Inspector Name and Property Address.");
      return;
    }
    if (!hasData) {
      setErrorMsg("Please add at least one photo or voice note.");
      return;
    }

    setIsGenerating(true);
    setErrorMsg("");

    // Extract descriptions for the AI
    const imageDescriptions = images
        .filter(img => img.status === 'success')
        .map(img => img.analysis);

    const res = await generateReport({
      notes: notes.join("\n"),
      imageDescriptions,
      details,
    });

    if (res.success && res.report) {
      setReport(res.report);
    } else {
      setErrorMsg(res.error || "Generation failed.");
    }
    setIsGenerating(false);
  };

  const handleCopy = async () => {
    await navigator.clipboard.writeText(report);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleDownloadText = () => {
    const slug = (details.propertyAddress || "inspection")
      .replace(/[^a-z0-9]/gi, "-")
      .toLowerCase();
    const el = document.createElement("a");
    el.href = URL.createObjectURL(new Blob([report], { type: "text/plain" }));
    el.download = `Report-${slug}.txt`;
    el.click();
  };

  const handleDownloadPDF = async () => {
    const doc = new jsPDF({ unit: "mm", format: "a4" });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const margin = 15;
    const contentW = pageW - margin * 2;
    let y = margin;

    const addFooter = (pageNum: number) => {
        doc.setFontSize(8);
        doc.setTextColor(150);
        doc.text(`Page ${pageNum} | Generated by FieldScribe`, pageW / 2, pageH - 8, { align: 'center' });
    };

    let pageCount = 1;

    const newPage = () => {
      addFooter(pageCount);
      doc.addPage();
      pageCount++;
      y = margin;
    };

    const checkSpace = (height: number) => {
      if (y + height > pageH - 20) newPage();
    };

    // ── COVER PAGE ──
    // Header Bar
    doc.setFillColor(55, 65, 81); // Slate 700
    doc.rect(0, 0, pageW, 20, "F");
    
    doc.setFont("helvetica", "bold");
    doc.setFontSize(16);
    doc.setTextColor(255, 255, 255);
    doc.text("INSPECTION REPORT", margin, 13);
    
    y = 40;

    // Property Photo (Smart Selection)
    if (images.length > 0) {
        try {
            // Heuristic: Prefer "exterior", "house", "front", "building"
            let coverImgIndex = 0;
            const keywords = ["exterior", "house", "front", "building", "elevation", "street", "facade"];
            
            for (let i = 0; i < images.length; i++) {
                const desc = images[i].analysis.toLowerCase();
                if (keywords.some(k => desc.includes(k))) {
                    coverImgIndex = i;
                    break;
                }
            }

            const coverImg = images[coverImgIndex];
            const imgProps = doc.getImageProperties(coverImg.preview);
            const imgH = (imgProps.height * contentW) / imgProps.width;
            
            // Limit cover image height
            const maxH = 110; 
            const finalH = imgH > maxH ? maxH : imgH;
            
            doc.addImage(coverImg.preview, "JPEG", margin, y, contentW, finalH);
            y += finalH + 15;
        } catch (err) {
            console.warn("Could not add cover image", err);
        }
    } else {
        // Placeholder box if no images
        doc.setFillColor(240, 240, 240);
        doc.rect(margin, y, contentW, 80, "F");
        doc.setTextColor(150);
        doc.setFontSize(14);
        doc.text("No Property Photo", pageW/2, y + 40, { align: 'center' });
        y += 90;
    }

    // Property Details
    doc.setTextColor(30);
    doc.setFontSize(22);
    doc.setFont("helvetica", "bold");
    doc.text(details.propertyAddress || "Property Address Not Provided", margin, y);
    y += 10;

    doc.setFontSize(12);
    doc.setFont("helvetica", "normal");
    doc.text(`Client: ${details.clientName || "—"}`, margin, y);
    y += 6;
    doc.text(`Date: ${details.date}`, margin, y);
    y += 15;

    // Inspector Badge
    doc.setDrawColor(200);
    doc.setFillColor(250, 250, 250);
    doc.roundedRect(margin, y, contentW, 35, 2, 2, "FD");
    doc.setTextColor(30);
    doc.setFont("helvetica", "bold");
    doc.text("INSPECTOR", margin + 5, y + 8);
    doc.setFont("helvetica", "normal");
    doc.text(details.inspectorName || "—", margin + 5, y + 16);
    doc.text(details.companyName || "", margin + 5, y + 22);
    doc.text(details.companyAddress || "", margin + 5, y + 28);
    
    addFooter(pageCount);
    doc.addPage();
    pageCount++;
    y = margin;

    // ── REPORT BODY ──
    
    const lines = report.split("\n");

    for (const rawLine of lines) {
      const line = rawLine.trimEnd();

      if (line.startsWith("# ")) {
        continue; // Skip main title as cover page handles it
      }

      // H2 Section Header (e.g. "Findings by System", "Executive Summary")
      if (line.startsWith("## ")) {
        checkSpace(20);
        y += 8;
        // Section Block
        doc.setFillColor(240, 242, 245); 
        doc.rect(margin, y, contentW, 10, "F");
        doc.setFontSize(12);
        doc.setFont("helvetica", "bold");
        doc.setTextColor(55, 65, 81);
        doc.text(line.replace(/^## /, "").toUpperCase(), margin + 2, y + 7);
        y += 16;
        continue;
      }

      // H3 Subsection (e.g. "Roofing System", "Kitchen")
      if (line.startsWith("### ")) {
        checkSpace(15);
        y += 5;
        // Divider line above
        doc.setDrawColor(200);
        doc.setLineWidth(0.1);
        doc.line(margin, y, margin + contentW, y);
        y += 6;
        
        doc.setFontSize(11);
        doc.setFont("helvetica", "bold");
        doc.setTextColor(30);
        doc.text(line.replace(/^### /, ""), margin, y);
        y += 7;
        continue;
      }

      // Bold Key-Value pairs (e.g. **Observation:** ...)
      if (line.startsWith("**") || line.includes("**")) {
        checkSpace(6);
        doc.setFontSize(10);
        doc.setTextColor(30);
        
        const parts = line.split("**");
        let currentX = margin;
        
        // Handle list bullet indent if implied
        if (line.trim().startsWith("- ") || line.trim().startsWith("• ")) {
            currentX += 5;
        }

        parts.forEach((part, i) => {
            if (part === "") return;
            // Clean markers
            const cleanPart = part.replace(/^[-•] /, ""); 
            
            doc.setFont("helvetica", i % 2 === 1 ? "bold" : "normal"); // Odd index inside ** is bold
            doc.text(cleanPart, currentX, y);
            currentX += doc.getStringUnitWidth(cleanPart) * 3.52; 
        });
        y += 6;
        continue;
      }

      // Standard Bullet points without bolding (fallback)
      if (line.startsWith("- ") || line.startsWith("• ")) {
        checkSpace(6);
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(50);
        const text = line.replace(/^[-•] /, "");
        
        const splitText = doc.splitTextToSize(text, contentW - 5);
        doc.text("•", margin, y);
        doc.text(splitText, margin + 5, y);
        y += (splitText.length * 5) + 2;
        continue;
      }

      // Standard Paragraph
      if (line.length > 0) {
        checkSpace(5);
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(50);
        const splitText = doc.splitTextToSize(line, contentW);
        doc.text(splitText, margin, y);
        y += (splitText.length * 5) + 2;
      }
    }

    // ── PHOTO ADDENDUM ──
    if (images.length > 0) {
        doc.addPage();
        pageCount++;
        y = margin;
        
        // Header
        doc.setFillColor(240, 242, 245);
        doc.rect(margin, y, contentW, 10, "F");
        doc.setFontSize(12);
        doc.setFont("helvetica", "bold");
        doc.setTextColor(55, 65, 81);
        doc.text("PHOTO ADDENDUM", margin + 2, y + 7);
        y += 18;

        for (let i = 0; i < images.length; i++) {
            const img = images[i];
            // 2 photos per page max (approx 110mm height each block)
            checkSpace(110); 
            
            try {
                // Add Image
                const imgProps = doc.getImageProperties(img.preview);
                const ratio = imgProps.width / imgProps.height;
                const imgW = 120; // Fixed width
                const imgH = imgW / ratio;
                
                // Keep ratio but fit on page
                doc.addImage(img.preview, "JPEG", margin, y, imgW, imgH);
                
                // Add Label
                doc.setFontSize(9);
                doc.setFont("helvetica", "bold");
                doc.setTextColor(30);
                doc.text(`Photo ${i+1}: Item of Interest`, margin + imgW + 5, y + 5);
                
                // Add Description
                doc.setFontSize(9);
                doc.setFont("helvetica", "normal");
                doc.setTextColor(80);
                
                // Clean description if it repeats "Description:"
                const cleanDesc = img.analysis.replace(/^Description:\s*/i, "");
                const splitCaption = doc.splitTextToSize(cleanDesc, contentW - imgW - 10);
                
                doc.text(splitCaption, margin + imgW + 5, y + 12);
                
                y += imgH + 15;
            } catch (err) {
                console.error("Error adding image to PDF", err);
            }
        }
        addFooter(pageCount);
    }

    const slug = (details.propertyAddress || "report").replace(/[^a-z0-9]/gi, "-");
    doc.save(`FieldScribe-Report-${slug}.pdf`);
  };

  return (
    <div className="space-y-4">
      {/* Controls */}
      <div className="flex items-center justify-between">
        <div className="text-sm text-slate-400">
          {images.length} photo{images.length !== 1 ? "s" : ""}, {notes.length} note{notes.length !== 1 ? "s" : ""}
        </div>
        <button
          onClick={handleGenerate}
          disabled={isGenerating || (!hasData && !hasDetails)}
          className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-semibold hover:bg-indigo-700 disabled:opacity-40 disabled:cursor-not-allowed shadow-sm transition-all hover:shadow-md"
        >
          {isGenerating ? <Loader2 className="w-4 h-4 animate-spin" /> : <Wand2 className="w-4 h-4" />}
          {isGenerating ? "Generating..." : report ? "Regenerate" : "Generate Report"}
        </button>
      </div>

      {errorMsg && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-100 rounded-lg text-sm text-red-700">
          <AlertCircle className="w-4 h-4 shrink-0 mt-0.5" />
          <span>{errorMsg}</span>
        </div>
      )}

      {/* Preview */}
      {report ? (
        <div className="border border-slate-200 rounded-xl bg-white shadow-sm overflow-hidden">
          {/* Toolbar */}
          <div className="flex items-center justify-between px-4 py-2.5 border-b border-slate-100 bg-slate-50">
            <span className="text-xs font-medium text-slate-500 uppercase tracking-wide">
              Preview
            </span>
            <div className="flex gap-2">
              <button
                onClick={handleCopy}
                className="flex items-center gap-1.5 text-xs text-slate-500 hover:text-slate-800 px-2 py-1 rounded hover:bg-slate-100 transition-colors"
              >
                {copied ? (
                  <CheckCheck className="w-3.5 h-3.5 text-green-500" />
                ) : (
                  <Copy className="w-3.5 h-3.5" />
                )}
                {copied ? "Copied!" : "Copy"}
              </button>
              <button
                onClick={handleDownloadText}
                className="flex items-center gap-1.5 text-xs text-slate-500 hover:text-slate-800 px-2 py-1 rounded hover:bg-slate-100 transition-colors"
              >
                <FileType className="w-3.5 h-3.5" />
                TXT
              </button>
              <button
                onClick={handleDownloadPDF}
                className="flex items-center gap-1.5 text-xs bg-slate-900 text-white px-3 py-1 rounded hover:bg-slate-700 transition-colors"
              >
                <Download className="w-3.5 h-3.5" />
                PDF
              </button>
            </div>
          </div>

          {/* Content */}
          <div className="p-4 max-h-[600px] overflow-y-auto">
            <pre className="whitespace-pre-wrap font-mono text-xs text-slate-700 leading-relaxed">
              {report}
            </pre>
          </div>
        </div>
      ) : (
        <div className="border-2 border-dashed border-slate-100 rounded-xl p-12 text-center text-slate-400 bg-slate-50/50">
          <FileText className="h-10 w-10 mx-auto mb-3 opacity-20" />
          <p className="text-sm">
            Fill in details, upload photos, and add voice notes, then click{" "}
            <strong className="text-slate-500">Generate Report</strong>.
          </p>
        </div>
      )}
    </div>
  );
}
